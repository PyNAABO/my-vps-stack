name: Deploy to VPS

on:
  push:
    branches: ["main"]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        env:
          TUNNEL_CREDENTIALS: ${{ secrets.TUNNEL_CREDENTIALS }}
        with:
          envs: TUNNEL_CREDENTIALS
          host: ${{ secrets.VPS_IP }}
          username: root
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            # 0. Cold Start (Auto-clone if missing)
            if [ ! -d "/root/my-vps-stack" ]; then
              echo "üöÄ Cold Start: Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git /root/my-vps-stack
            fi
            cd /root/my-vps-stack

            # 1. Update Code (force reset to handle local changes)
            git fetch origin main
            git reset --hard origin/main

            # 2. Setup Directories & Env
            mkdir -p config/tunnel config/fb config/qbit
            : > .env  # Clear .env (safer than echo)

            # 3. Auto-generate docker-compose.yml from apps/*/docker-compose.yml
            echo "# Auto-generated - DO NOT EDIT" > docker-compose.yml
            echo "# Add/remove apps by adding/removing folders in apps/" >> docker-compose.yml
            echo "" >> docker-compose.yml
            echo "include:" >> docker-compose.yml
            for compose_file in apps/*/docker-compose.yml; do
              if [ -f "$compose_file" ]; then
                app_name=$(basename "$(dirname "$compose_file")")
                # Skip template folder (not a real app)
                if [ "$app_name" = "_template" ]; then
                  echo "  ‚è≠Ô∏è  Skipped: $compose_file (template)"
                  continue
                fi
                echo "  - $compose_file" >> docker-compose.yml
                echo "  ‚úì Included: $compose_file"
              fi
            done

            # 4. Generate Tunnel Config from apps/*/ingress.yml
            if [ -n "${{ secrets.DOMAIN }}" ] && [ -n "${{ secrets.TUNNEL_CREDENTIALS }}" ]; then
              echo "‚úÖ Generating Tunnel Config..."
              echo "$TUNNEL_CREDENTIALS" > config/tunnel/cert.json
              
              # Build tunnel config header
              echo "tunnel: ${{ secrets.TUNNEL_ID }}" > config/tunnel/config.yml
              echo "credentials-file: /etc/cloudflared/cert.json" >> config/tunnel/config.yml
              echo "ingress:" >> config/tunnel/config.yml
              
              # Dynamically add ingress rules from each app's ingress.yml

              # Install yq pinned version
              if ! command -v yq &>/dev/null; then
                wget -qO /usr/bin/yq https://github.com/mikefarah/yq/releases/download/v4.40.5/yq_linux_amd64 && chmod +x /usr/bin/yq
              fi
              
              for ingress_file in apps/*/ingress.yml; do
                if [ -f "$ingress_file" ]; then
                  app_name=$(basename "$(dirname "$ingress_file")")
                  # Skip template folder (not a real app)
                  if [ "$app_name" = "_template" ]; then
                    echo "  ‚è≠Ô∏è  Skipped ingress: $ingress_file (template)"
                    continue
                  fi
                  hostname=$(yq '.hostname' "$ingress_file")
                  service=$(yq '.service' "$ingress_file")
                  echo "  - hostname: ${hostname}.${{ secrets.DOMAIN }}" >> config/tunnel/config.yml
                  echo "    service: ${service}" >> config/tunnel/config.yml
                  echo "  ‚úì Added route: ${hostname} -> ${service}"
                fi
              done
              
              # Add catch-all 404
              echo "  - service: http_status:404" >> config/tunnel/config.yml

              echo "DOMAIN_NAME=${{ secrets.DOMAIN }}" >> .env
              
              # Force tunnel to reload new config
              docker restart my-vps-stack-tunnel 2>/dev/null || true
            else
              echo "‚ö†Ô∏è Fallback Mode"
              echo "DOMAIN_NAME=localhost" >> .env
            fi

            # 5. Inject Bot Configs
            echo "TG_BOT_TOKEN=${{ secrets.TG_BOT_TOKEN }}" >> .env
            echo "ALLOWED_GROUP_ID=${{ secrets.ALLOWED_GROUP_ID }}" >> .env

            # 6. Generate Dashboard from ingress.yml files
            bash apps/dashboard/generate.sh "${{ secrets.DOMAIN }}"

            # 7. Run init scripts for each app (first-time setup)
            for init_script in apps/*/init.sh; do
              if [ -f "$init_script" ]; then
                app_name=$(basename "$(dirname "$init_script")")
                # Skip template folder (not a real app)
                if [ "$app_name" = "_template" ]; then
                  echo "  ‚è≠Ô∏è  Skipped: $init_script (template)"
                  continue
                fi
                echo "üîß Running $init_script"
                bash "$init_script"
              fi
            done

            # 8. Deployment
            sysctl -w net.core.rmem_max=2500000 || true
            docker compose up -d --build --remove-orphans --wait
            docker image prune -f
            echo "‚úÖ Deployment Completed!"
